import {validateYaml, validateSchema} from '../src/check-config.js';
import Octokit from '@octokit/rest';
import {describe, it} from 'mocha';
import assert from 'assert';
import * as fs from 'fs';
import snapshot from 'snap-shot-it';
import yaml from 'js-yaml';

describe('check for config', () => {
  it('should return error message if YAML is invalid', () => {
    assert.strictEqual(
      validateYaml(
        fs.readFileSync(
          './test/fixtures/config/invalid-yaml-config.yml',
          'utf8'
        )
      ),
      false
    );
  });

  it('should return true if YAML is valid', async () => {
    assert.strictEqual(
      validateYaml(
        fs.readFileSync('./test/fixtures/config/valid-schemas/valid-schema1.yml', 'utf8')
      ),
      true
    );
  });

  it('should return false if YAML has invalid schema', async () => {    
    async function invalidateSchema (configNum: number) {
      return (await validateSchema(
      yaml.load(
        fs.readFileSync(
          `./test/fixtures/config/invalid-schemas/invalid-schema${configNum}.yml`,
          'utf8'
        )
      )
      ));
    }
    //does not have any additional properties
    assert.deepStrictEqual(await invalidateSchema(1),  
      [
        {
          wrongProperty: { additionalProperty: 'notTheRules' },
          message: 'should NOT have additional properties'
        }
      ]
        
);

    //title does not correspond to author
    assert.deepStrictEqual(await invalidateSchema(2), [
      {
        wrongProperty: { allowedValue: 'chore: regenerate README' },
        message: 'should be equal to constant'
      }
    ]);

   //title does not correspond to author
   assert.deepStrictEqual(await invalidateSchema(3), [
    {
      wrongProperty: { allowedValue: '^chore: release' },
      message: 'should be equal to constant'
    }
  ]);

    //title does not correspond to author
    assert.deepStrictEqual(await invalidateSchema(4), [
      {
        wrongProperty: { allowedValue: '^chore: autogenerated discovery document update' },
        message: 'should be equal to constant'
      }
    ]);

    //author is not allowed
    assert.deepStrictEqual(await invalidateSchema(5),   [
      {
        message: 'should be equal to one of the allowed values',
        wrongProperty: {
          allowedValues: [
           'googleapis-publisher',
           'yoshi-automation',
           'yoshi-code-bot'
          
    ]}}
    ]);

    //missing 'title' property
    assert.deepStrictEqual(await invalidateSchema(6), [
      {
        wrongProperty: { missingProperty: 'title' },
        message: "should have required property 'title'"
      }
    ]);

    //empty array
    assert.deepStrictEqual(await invalidateSchema(7), [ { wrongProperty: { type: 'object' }, message: 'should be object' } ]);

    //duplicate items
    assert.deepStrictEqual(await invalidateSchema(8), [
      {
        wrongProperty: { i: 1, j: 0 },
        message: 'should NOT have duplicate items (items ## 0 and 1 are identical)'
      }
    ]);


  });

  it('should return true if YAML has valid schema', async () => {
    assert.strictEqual(await validateSchema(
      yaml.load(
        fs.readFileSync(
          './test/fixtures/config/valid-schemas/valid-schema1.yml',
          'utf8'
        )
      )
    ), true);

    assert.strictEqual(await validateSchema(
      yaml.load(
        fs.readFileSync(
          './test/fixtures/config/valid-schemas/valid-schema2.yml',
          'utf8'
        )
      )
    ), true);

    assert.strictEqual(await validateSchema(
      yaml.load(
        fs.readFileSync(
          './test/fixtures/config/valid-schemas/valid-schema3.yml',
          'utf8'
        )
      )
    ), true);
  });
});
